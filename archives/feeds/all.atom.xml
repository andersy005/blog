<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Anderson Banihirwe</title><link href="https://andersy005.github.io/" rel="alternate"></link><link href="https://andersy005.github.io/feeds/all.atom.xml" rel="self"></link><id>https://andersy005.github.io/</id><updated>2020-01-21T00:00:00-06:00</updated><subtitle></subtitle><entry><title>A Knitting Weekend</title><link href="https://andersy005.github.io/blog/2020/01/21/a-knitting-weekend/" rel="alternate"></link><published>2020-01-21T00:00:00-06:00</published><updated>2020-01-21T00:00:00-06:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2020-01-21:blog/2020/01/21/a-knitting-weekend/</id><summary type="html">

&lt;p&gt;Sitting in a chair in front a computer screen while listening to MIX 100 Denver Radio station (for hours ðŸ˜€), I was reminded of the intriguing parallels between &lt;a href="https://www.nytimes.com/2019/05/17/science/math-physics-knitting-matsumoto.html"&gt;knitting and programming&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Knitting is Coding, and Yarn is a Programmable material."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;On quiet weekends like this I write code for fun, and Visual Studio Code &amp;amp; Python are my yarn and needles.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Sometimes a quiet weekend is an absolute gift!&lt;/em&gt;&lt;/p&gt;
</summary><category term="knitting"></category><category term="python"></category><category term="vscode"></category><category term="dash"></category></entry><entry><title>Reflecting on SciPy 2019, My First SciPy, Definitely Not The Last</title><link href="https://andersy005.github.io/blog/2019/07/21/scipy-2019/" rel="alternate"></link><published>2019-07-21T00:00:00-05:00</published><updated>2019-07-21T00:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2019-07-21:blog/2019/07/21/scipy-2019/</id><summary type="html">

&lt;p&gt;I left SciPy 2019 feeling:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;very thankful&lt;/strong&gt; that so many amazing people are able to come out and collaborate on the projects that are so vital to the Python scientific ecocystem!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;grateful&lt;/strong&gt; to be part of this community.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;inspired&lt;/strong&gt; to keep contributing to this community.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;so excited&lt;/strong&gt; about the technology, the science, and the people.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="scipy"></category><category term="python"></category><category term="conference"></category></entry><entry><title>The Sheer Joy of Accelerating Your Existing Python Code with Numba! - Part I</title><link href="https://andersy005.github.io/blog/2019/01/12/numba-series-part-i/" rel="alternate"></link><published>2019-01-12T00:00:00-06:00</published><updated>2019-01-12T00:00:00-06:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2019-01-12:blog/2019/01/12/numba-series-part-i/</id><summary type="html">&lt;/p&gt;
&lt;h2 id="What-is-Numba?"&gt;What is Numba?&lt;a class="anchor-link" href="#What-is-Numba?"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;a JIT (Just-in-Time) compiler for Python that:&lt;/p&gt;







&lt;ul&gt;
&lt;li&gt;generates optimized machine code using LLVM (Low Level Virtual Machine) compiler infrastructure&lt;/li&gt;
&lt;/ul&gt;







&lt;ul&gt;
&lt;li&gt;provides toolbox for different targets and execution models:&lt;ul&gt;
&lt;li&gt;Single-threaded CPU, multi-threaded CPU, GPU&lt;/li&gt;
&lt;li&gt;regular functions, "universal functions (ufuncs)" (array functions), etc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;ul&gt;
&lt;li&gt;integrates well with the Scientific Python stack&lt;/li&gt;
&lt;/ul&gt;







&lt;ul&gt;
&lt;li&gt;with a few annotations, array-oriented and math-heavy Python code provides: &lt;ul&gt;
&lt;li&gt;speedup: 2x (compared to basic NumPy code) to 200x (compared to pure Python)&lt;/li&gt;
&lt;li&gt;performance similar to C, C++, Fortran, without having to switch languages or Python interpreters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;ul&gt;
&lt;li&gt;is &lt;strong&gt;totally awesome!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="python"></category><category term="numba"></category><category term="jit"></category><category term="code optimization"></category></entry><entry><title>TVM: End-to-End Optimization Stack for Deep Learning</title><link href="https://andersy005.github.io/blog/2018/05/10/tvm-paper-summary/" rel="alternate"></link><published>2018-05-10T00:00:00-05:00</published><updated>2018-05-10T00:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-05-10:blog/2018/05/10/tvm-paper-summary/</id><summary type="html">

&lt;p&gt;&lt;img src="https://i.imgur.com/pA2pcl4.png" alt=""&gt; (Image Source: &lt;a href="http://tvmlang.org/"&gt;http://tvmlang.org/&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id="Abstract"&gt;Abstract&lt;a class="anchor-link" href="#Abstract"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Scalable frameworks, such as TensorFlow, MXNet, Caffe, and PyTorch are optimized for a narrow range of serve-class GPUs.&lt;/li&gt;
&lt;li&gt;Deploying workloads to other platforms such as mobile phones, IoT, and specialized accelarators(FPGAs, ASICs) requires laborious manual effort.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TVM is an end-to-end optimization stack that exposes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;graph-level&lt;/li&gt;
&lt;li&gt;operator-level optimizations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;---&amp;gt; to provide performance portability to deep learning workloads across diverse hardware back-ends.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="compiler"></category><category term="tensor"></category><category term="deep-learning"></category><category term="gpu"></category><category term="tvm"></category></entry><entry><title>Kube In Action - 02: Containers</title><link href="https://andersy005.github.io/blog/2018/04/19/kube-in-action-part-ii/" rel="alternate"></link><published>2018-04-19T21:00:00-05:00</published><updated>2018-04-19T21:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-04-19:blog/2018/04/19/kube-in-action-part-ii/</id><summary type="html">

&lt;p&gt;A process running in a container runs inside the host's operating system, like all other processes. But the process in the container is still isolated from other processes. To the process itself, it looks like it is only one running on the machine and in its operating system.&lt;/p&gt;







&lt;p&gt;&lt;img src="https://i.imgur.com/uYGIEtg.png" alt=""&gt;&lt;/p&gt;
</summary><category term="kubernetes"></category><category term="containerization"></category></entry><entry><title>Kube In Action - 01: Introduction to Kubernetes</title><link href="https://andersy005.github.io/blog/2018/04/19/kube-in-action-part-i/" rel="alternate"></link><published>2018-04-19T19:00:00-05:00</published><updated>2018-04-19T19:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-04-19:blog/2018/04/19/kube-in-action-part-i/</id><summary type="html">

&lt;p&gt;I've recently picked up an interest in &lt;a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization"&gt;containerization&lt;/a&gt;. I started reading up on and playing with &lt;a href="https://kubernetes.io/"&gt;kubernetes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I have been taking notes as I go through &lt;a href="https://www.manning.com/books/kubernetes-in-action"&gt;Kubernetes in Action by Marko LukÅ¡a &lt;/a&gt; and I wanted to share these with those who might have similar interests in containerization and distributed systems in general. &lt;em&gt;This is the 1st installment of a series called&lt;/em&gt; &lt;strong&gt;Kube in Action&lt;/strong&gt;. Every week or so, Iâ€™ll be summarizing and exploring &lt;strong&gt;kubernetes fundamentals + concepts with hands-on examples&lt;/strong&gt; as I learn more about Kubernetes. 
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://d33wubrfki0l68.cloudfront.net/55f2f273b05a44c1d87908e4b749ffcd530a8495/ddfb6/images/blog-logging/2018-04-10-container-storage-interface-beta/csi-kubernetes.png" width="200" align="center"&gt;&lt;/p&gt;
</summary><category term="kubernetes"></category><category term="containerization"></category></entry><entry><title>Binary Trees</title><link href="https://andersy005.github.io/blog/2018/03/23/Binary%20Trees/" rel="alternate"></link><published>2018-03-23T00:00:00-05:00</published><updated>2018-03-23T00:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-03-23:blog/2018/03/23/Binary Trees/</id><summary type="html">
A binary tree is made of nodes, where each node contains a &lt;b&gt;left&lt;/b&gt; pointer, a &lt;b&gt;right&lt;/b&gt; pointer, and a data element. The &lt;b&gt;root&lt;/b&gt; pointer points to the topmost node in the tree.

&lt;img src="https://cdn-images-1.medium.com/max/800/1*UjSfPoMwCEkke1_iuNZ1EQ.jpeg"&gt;

</summary><category term="data structures"></category><category term="algorithms"></category></entry><entry><title>NBA games results visualization with Holoviews</title><link href="https://andersy005.github.io/blog/2018/03/20/NBA-games-results-visualization-with-Holoviews/" rel="alternate"></link><published>2018-03-20T21:00:00-05:00</published><updated>2018-03-20T21:00:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-03-20:blog/2018/03/20/NBA-games-results-visualization-with-Holoviews/</id><summary type="html">
&lt;img src="https://projects.fivethirtyeight.com/2018-nba-predictions/images/transparent-whiteshoe-cut.gif" width="100" height="50" align="left"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://camo.githubusercontent.com/a7ac304b1dce0e5b4d89d63606526ecf780b8d0f/687474703a2f2f6173736574732e686f6c6f76696577732e6f72672f6c6f676f2f686f6c6f76696577735f636f6c6f725f69636f6e5f353030783530302e706e67" width="100" height="50" align="center"&gt;&lt;/p&gt;
&lt;p&gt;</summary><category term="visualization"></category><category term="holoviews"></category></entry><entry><title>Play interactively with C++ - Sequence Containers</title><link href="https://andersy005.github.io/blog/2018/01/23/play-interactively-with-cpp-sequence-containers/" rel="alternate"></link><published>2018-01-23T21:00:00-06:00</published><updated>2018-01-23T21:00:00-06:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-01-23:blog/2018/01/23/play-interactively-with-cpp-sequence-containers/</id><summary type="html">

&lt;p&gt;The Standard Template Library (STL) is a programmer's dream. It offers efficient ways to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;store&lt;/li&gt;
&lt;li&gt;access&lt;/li&gt;
&lt;li&gt;manipulate&lt;/li&gt;
&lt;li&gt;view data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and is designed for maximum extensibility. Once a programmer has gotten over the initial syntax hurdles, they quickly learn to appreciate the STL's sheer power and flexibility.&lt;/p&gt;
&lt;h2 id="Overview-of-STL"&gt;Overview of STL&lt;a class="anchor-link" href="#Overview-of-STL"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src="https://i.imgur.com/zO1sozu.png" alt=""&gt;
Source: CS106L-Stanford
</summary><category term="xeus-cling"></category><category term="c++"></category><category term="programming"></category><category term="jupyter"></category></entry><entry><title>Play interactively with C++ - Streams</title><link href="https://andersy005.github.io/blog/2018/01/20/play-interactively-with-cpp-streams/" rel="alternate"></link><published>2018-01-20T16:00:00-06:00</published><updated>2018-01-20T16:00:00-06:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-01-20:blog/2018/01/20/play-interactively-with-cpp-streams/</id><summary type="html">

&lt;p&gt;A stream is an abstraction for input/output.
You can think of it as a source (input) or destination (output) of 
characters of indefinite length.
&lt;img src="http://www.cplusplus.com/img/iostream.gif" alt=""&gt;&lt;/p&gt;
</summary><category term="xeus-cling"></category><category term="c++"></category><category term="programming"></category><category term="jupyter"></category></entry><entry><title>Play interactively with C++ - Getting Started with Xeus-Cling</title><link href="https://andersy005.github.io/blog/2018/01/20/play-interactively-with-cpp-getting-started-with-xeus-cling/" rel="alternate"></link><published>2018-01-20T15:00:00-06:00</published><updated>2018-01-20T15:00:00-06:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2018-01-20:blog/2018/01/20/play-interactively-with-cpp-getting-started-with-xeus-cling/</id><summary type="html">
&lt;img src="https://github.com/QuantStack/xeus-cling/raw/master/docs/source/xeus-cling.svg?sanitize=true" alt="xeus-cling"&gt;&lt;/p&gt;







&lt;p&gt;&lt;em&gt;This is the 1st installment of a new series called&lt;/em&gt; &lt;strong&gt;Play interactively with C++&lt;/strong&gt;. Every week or so, Iâ€™ll be summarizing and exploring &lt;strong&gt;Standard C++ Programming&lt;/strong&gt; in Jupyter notebook using &lt;a href="https://github.com/QuantStack/xeus-cling"&gt;xeus-cling&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The source code (in notebook format) for this series can be found &lt;a href="http://nbviewer.jupyter.org/github/andersy005/interactive-cpp/tree/master/"&gt;here&lt;/a&gt;.&lt;/p&gt;







&lt;p&gt;xeus-cling is a Jupyter kernel for C++ based on the C++ interpreter &lt;a href="https://github.com/root-project/cling"&gt;cling&lt;/a&gt; and the native implementation of the Jupyter protocol &lt;a href="https://github.com/QuantStack/xeus"&gt;xeus&lt;/a&gt;.&lt;/p&gt;
</summary><category term="xeus-cling"></category><category term="c++"></category><category term="programming"></category><category term="jupyter"></category></entry><entry><title>Why Parallel Computing?</title><link href="https://andersy005.github.io/blog/2017/10/20/why-parallel-computing/" rel="alternate"></link><published>2017-10-20T11:30:00-05:00</published><updated>2017-10-20T11:30:00-05:00</updated><author><name>Anderson Banihirwe</name></author><id>tag:andersy005.github.io,2017-10-20:blog/2017/10/20/why-parallel-computing/</id><summary type="html">

&lt;p&gt;For many years weâ€™ve enjoyed the fruits of ever faster processors. However, because
of  physical  limitations  the  rate  of  performance  improvement  in  conventional  processors  is  decreasing.  In  order to  increase  the  power  of  processors,  chipmakers have turned to
multicore integrated circuits, that is, integrated circuits with multiple
conventional processors on a single chip.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/rLbJhqZ.png"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;(Source: &lt;a href="https://www.top500.org/statistics/perfdevel/"&gt;Exponential growth of supercomputing power as recorded by the TOP500 list&lt;/a&gt;)
</summary><category term="parallel computing"></category><category term="distributed computing"></category><category term="hpc"></category></entry></feed>